# goit-algo-hw-04

[Алгоритми сортування](https://www.edu.goit.global/uk/learn/13571785/19646173/19656826/training)

Результати вимірювання трьох алгоритмів сортування на різних наборах даних:

````
========== розмір масиву: 1000 ==========
insertion_sort  > 0.024156999999831896    
merge_sort      > 0.0016099999993457459   
timesort_sort   > 5.599999894911889e-06   

========== розмір масиву: 10000 ==========
insertion_sort  > 2.2206279000001814  
merge_sort      > 0.018847100000130013
timesort_sort   > 4.569999964587623e-05   

========== розмір масиву: 20000 ==========
insertion_sort  > 9.224944399999913
merge_sort      > 0.04430320000028587  
timesort_sort   > 8.940000043367036e-05
````

Підтверджено часову складність сортування вставками: час збільшується кваратично зі збільшенням розміну вхідного масиву.
Підтверджено часову складність сортування злиттям: час збільшується логаріфмічно-лінійно зі збільшенням розміну вхідного масиву.
Timsort працює значно швидше попередніх алгоритмів на різних розмірах наборів даних. Це підтверджує теоретичні властивості алгоритма Timsort, який ефективно використовує сортування злиттям та сортування вставками в залежності від характеристик даних.

Отже, поєднання сортування злиттям та сортування вставками робить Timsort ефективним для різних сценаріїв та розмірів даних, що робить його відмінним вибором для використання в Python. Програмісти в більшості випадків використовують вбудовані алгоритми, такі як Timsort, замість власноруч написаних, оскільки ці алгоритми оптимізовані та вже випробувані на різних типах даних.